---
name: GitHub Actions Lint

"on":
  push:
    branches:
      - "main"
      - "dev"
      - "feat/**"
      - "branch/**"
      - "feature/**"
      - "fix/**"
      - "pr/**"
  pull_request:
    branches:
      - "main"
      - "dev"
      - "feat/**"
      - "branch/**"
      - "feature/**"
      - "fix/**"
      - "pr/**"
  workflow_dispatch:

jobs:
  lint:
    name: Run Linter
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4.2.2
        with:
          # Use default GITHUB_TOKEN for reliability unless cross-workflow triggers are needed.
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0 # Required for commitlint to see git history

      - name: Run Commitlint Check
        run: |
          npm install -g @commitlint/cli @commitlint/config-conventional
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            npx commitlint --from ${{ github.event.pull_request.base.sha }} --to ${{ github.event.pull_request.head.sha }} --verbose
          else
            npx commitlint --last --verbose
          fi

      - name: Install Gitleaks
        shell: bash
        env:
          GITHUB_PROXY: ${{ secrets.GITHUB_PROXY || vars.GH_PROXY || 'https://gh-proxy.sn0wdr1am.com/' }}
        run: |
          OS=$(uname -s | tr '[:upper:]' '[:lower:]')
          ARCH=$(uname -m)

          if [ "$OS" = "darwin" ]; then
            GL_OS="darwin"
          elif [ "$OS" = "linux" ]; then
            GL_OS="linux"
          elif [[ "$OS" == *"mingw"* || "$OS" == *"msys"* || "$OS" == *"cygwin"* ]]; then
            GL_OS="windows"
          else
            echo "Unsupported OS: $OS"
            exit 1
          fi

          if [ "$ARCH" = "x86_64" ] || [ "$ARCH" = "amd64" ]; then
            GL_ARCH="x64"
          elif [ "$ARCH" = "aarch64" ] || [ "$ARCH" = "arm64" ]; then
            GL_ARCH="arm64"
          elif [ "$ARCH" = "i386" ] || [ "$ARCH" = "i686" ]; then
            GL_ARCH="x32"
          else
            echo "Unsupported Architecture: $ARCH"
            exit 1
          fi

          echo "Detected OS: $GL_OS, Architecture: $GL_ARCH"
          GITLEAKS_VERSION=$(curl -s "https://api.github.com/repos/gitleaks/gitleaks/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
          if [ -z "$GITLEAKS_VERSION" ]; then
            echo "Warning: Failed to fetch latest Gitleaks version. Falling back to v8.21.2"
            GITLEAKS_VERSION="v8.21.2"
          fi
          GITLEAKS_VERSION_NUM=${GITLEAKS_VERSION#v}
          echo "Latest Gitleaks version: $GITLEAKS_VERSION"

          if [ "$GL_OS" = "windows" ]; then
            GL_ARCHIVE="gitleaks_${GITLEAKS_VERSION_NUM}_${GL_OS}_${GL_ARCH}.zip"
            GL_URL="${GITHUB_PROXY}https://github.com/gitleaks/gitleaks/releases/download/${GITLEAKS_VERSION}/${GL_ARCHIVE}"
            echo "Downloading $GL_URL"
            curl -sSL -o gitleaks.zip "$GL_URL"
            unzip gitleaks.zip -d gitleaks-bin
          else
            GL_ARCHIVE="gitleaks_${GITLEAKS_VERSION_NUM}_${GL_OS}_${GL_ARCH}.tar.gz"
            GL_URL="${GITHUB_PROXY}https://github.com/gitleaks/gitleaks/releases/download/${GITLEAKS_VERSION}/${GL_ARCHIVE}"
            echo "Downloading $GL_URL"
            mkdir -p gitleaks-bin
            curl -sSL "$GL_URL" | tar -xz -C gitleaks-bin gitleaks
          fi

          chmod +x gitleaks-bin/gitleaks*
          echo "$PWD/gitleaks-bin" >> "$GITHUB_PATH"

      - name: Run Gitleaks
        shell: bash
        run: gitleaks detect --source . --verbose

      - name: Set env variables
        run: |
          {
            echo "BRANCH=${GITHUB_REF##*/}"
            echo "http_proxy=${http_proxy}"
            echo "no_proxy=${no_proxy}"
          } >> "$GITHUB_ENV"

      - name: Set up Python
        uses: actions/setup-python@v6.2.0
        with:
          python-version: "3.12"

      # Set up standard Python virtual environment
      - name: Setup Virtual Environment
        run: |
          python3 -m venv .venv
          source .venv/bin/activate

      # Installing linting packages into our venv
      - name: Install Linters
        run: |
          source .venv/bin/activate
          pip install yamllint ansible-core ansible-lint ruff sqlfluff semgrep

      # Run yaml linting
      - name: Run yamllint
        run: |
          source .venv/bin/activate
          find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f \( -name '*.yaml' -o -name '*.yml' \) -print0 | xargs -0 yamllint

      # Setup Node.js for Markdown linting & JS-based tools
      - name: Set up Node.js
        uses: actions/setup-node@v6.2.0
        with:
          node-version: "20"

      - name: Install Node.js Linters
        run: npm install -g markdownlint-cli2 prettier editorconfig-checker cspell eslint

      - name: Install ShellCheck Binary
        env:
          GITHUB_PROXY: ${{ secrets.GITHUB_PROXY || vars.GH_PROXY || 'https://gh-proxy.sn0wdr1am.com/' }}
        run: |
          latest_version=$(curl -s "https://api.github.com/repos/koalaman/shellcheck/releases/latest" | grep -o '"tag_name"[[:space:]]*:[[:space:]]*"[^"]*"' | awk -F'"' '{print $4}')
          if [ -z "$latest_version" ]; then
            echo "Warning: Failed to fetch latest ShellCheck version API. Falling back to v0.10.0"
            latest_version="v0.10.0"
          fi
          os_name=$(uname -s | tr '[:upper:]' '[:lower:]')
          arch_name=$(uname -m)

          if [ "$os_name" = "darwin" ]; then
            sc_os="darwin"
          elif [ "$os_name" = "linux" ]; then
            sc_os="linux"
          else
            echo "Unsupported OS: $os_name"
            exit 1
          fi

          if [ "$arch_name" = "x86_64" ] || [ "$arch_name" = "amd64" ]; then
            sc_arch="x86_64"
          elif [ "$arch_name" = "aarch64" ] || [ "$arch_name" = "arm64" ]; then
            sc_arch="aarch64"
          else
            echo "Unsupported Architecture: $arch_name"
            exit 1
          fi

          sc_url="${GITHUB_PROXY}https://github.com/koalaman/shellcheck/releases/download/${latest_version}/shellcheck-${latest_version}.${sc_os}.${sc_arch}.tar.gz"
          echo "Downloading ShellCheck ${latest_version} from $sc_url"
          curl -fLo sc.tar.gz --retry 3 "$sc_url"
          mkdir -p shellcheck-latest
          tar -xzf sc.tar.gz -C shellcheck-latest --strip-components=1
          echo "$PWD/shellcheck-latest" >> "$GITHUB_PATH"

      # Run Markdown linting (exclusions are handled by .markdownlintignore)
      - name: Run markdownlint
        run: npx markdownlint-cli2

      # Core Ansible Linting phase
      - name: Run ansible-lint
        run: |
          source .venv/bin/activate
          ansible-lint -v

      # Ansible Playbook syntax validation
      # NOTE: continue-on-error until all roles (home, orchestrator) are implemented
      - name: Run ansible-playbook syntax-check
        continue-on-error: true
        run: |
          source .venv/bin/activate
          if [ -d playbooks ]; then
            find playbooks -name "*.yml" -print0 | xargs -0 -I{} ansible-playbook --syntax-check {}
          else
            echo "No playbooks/ directory found, skipping syntax-check."
          fi

      # Python Linting (Ruff)
      - name: Run Ruff
        run: |
          source .venv/bin/activate
          if [ -n "$(find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f -name '*.py' -print -quit)" ]; then
            ruff check .
            ruff format --check .
          else
            echo "No Python files found, skipping ruff."
          fi

      # SQL Linting (SQLFluff)
      - name: Run SQLFluff
        run: |
          source .venv/bin/activate
          if [ -n "$(find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f -name '*.sql' -print -quit)" ]; then
            sqlfluff lint . --dialect postgres
          else
            echo "No SQL files found, skipping sqlfluff."
          fi

      # JSON, YAML, Vue, JS, TS, & React formatting linting
      - name: Run Prettier
        run: npx prettier --check "**/*.{json,yml,yaml,vue,js,jsx,ts,tsx}"

      - name: Run editorconfig-checker
        run: npx editorconfig-checker -exclude "(\.(venv|git|github/agents|agent|agents|roo|claude|qwen|amazonq|augment|bob|codebuddy|codex|kilocode|opencode|qoder|shai|cursor|windsurf|pearai|pi|pochi|specify|supermaven|tabnine|trae|vibe|void|zed|zencoder|openhands|cody|coderabbit|aide|cline|clinerules|cursorrules|pr_agent.toml|tabnine|supermaven|vibe|void|zed)/.*)|((node_modules|venv|env|dist|build|out|target|vendor|__pycache__|\.specify/scripts)/.*)|(\.aider\.conf\.yml)"

      # Run Spell Checker (CSpell)
      # NOTE: continue-on-error can be removed once a custom dictionary is fully configured
      - name: Run CSpell (Spell Checker)
        continue-on-error: true
        run: npx cspell "**" --no-progress --no-summary --dot

      # Check for broken URLs and relative links in Markdown
      - name: Run Lychee (Link Checker)
        uses: lycheeverse/lychee-action@v2.8.0
        continue-on-error: true
        with:
          args: --base . --verbose --no-progress '**/*.md'
          fail: true

      # JavaScript / TypeScript linting
      # Only runs if an ESLint configuration file is detected
      - name: Run ESLint
        run: |
          if [ -f "eslint.config.js" ] || [ -f "eslint.config.mjs" ] || [ -f ".eslintrc.js" ] || [ -f ".eslintrc.json" ]; then
            echo "ESLint config found, running ESLint..."
            npx eslint "."
          else
            echo "No ESLint configuration found, skipping ESLint."
          fi

      # CSS / SCSS / LESS linting
      - name: Run Stylelint
        run: |
          if [ -n "$(find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f \( -name '*.css' -o -name '*.scss' -o -name '*.less' \) -print -quit)" ]; then
            npx stylelint "**/*.{css,scss,less}"
          else
            echo "No CSS/SCSS/LESS files found, skipping Stylelint."
          fi

      # TOML formatting linting
      - name: Run Taplo
        run: |
          if [ -n "$(find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f -name '*.toml' -print -quit)" ]; then
            npx @taplo/cli format --check
          else
            echo "No TOML files found, skipping Taplo."
          fi

      # Go Linting
      - name: Install GolangCI-Lint
        env:
          GITHUB_PROXY: ${{ secrets.GITHUB_PROXY || vars.GH_PROXY || 'https://gh-proxy.sn0wdr1am.com/' }}
        run: |
          mkdir -p ~/.local/bin
          curl -sSfL "${GITHUB_PROXY}https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh" | sh -s -- -b ~/.local/bin v1.56.2
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Run golangci-lint
        run: |
          if [ -n "$(find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f -name '*.go' -print -quit)" ]; then
            golangci-lint run
          else
            echo "No Go files found, skipping golangci-lint."
          fi

      # Rust Linting
      - name: Run Rustfmt and Clippy
        run: |
          if command -v cargo &> /dev/null && [ -f "Cargo.toml" ]; then
            echo "Cargo.toml found, running Rustfmt and Clippy..."
            cargo fmt -- --check
            cargo clippy -- -D warnings
          else
            echo "No Cargo.toml found or cargo not installed, skipping Rust linting."
          fi

      # .NET / C# Linting
      - name: Run dotnet format
        run: |
          if command -v dotnet &> /dev/null; then
            if [ -n "$(find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f \( -name '*.cs' -o -name '*.vb' \) -print -quit)" ]; then
              dotnet format --verify-no-changes
            else
              echo "No C#/VB files found, skipping dotnet format."
            fi
          else
            echo "dotnet SDK not installed, skipping .NET linting."
          fi

      # Ruby Linting
      - name: Run Rubocop
        run: |
          if command -v ruby &> /dev/null; then
            if [ -n "$(find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f -name '*.rb' -print -quit)" ]; then
              gem install rubocop
              rubocop --parallel
            else
              echo "No Ruby files found, skipping Rubocop."
            fi
          else
            echo "Ruby not installed, skipping Rubocop."
          fi

      # PHP Linting
      - name: Run php-cs-fixer
        run: |
          if command -v php &> /dev/null; then
            if [ -n "$(find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f -name '*.php' -print -quit)" ]; then
              curl -sL https://cs.symfony.com/download/php-cs-fixer-v3.phar -o php-cs-fixer
              php php-cs-fixer fix --dry-run
            else
              echo "No PHP files found, skipping php-cs-fixer."
            fi
          else
            echo "PHP not installed, skipping php-cs-fixer."
          fi

      # Dart & Flutter Linting
      - name: Run Dart Format and Analyze
        run: |
          if command -v dart &> /dev/null; then
            if [ -n "$(find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f -name '*.dart' -print -quit)" ]; then
              dart format --output=none --set-exit-if-changed .
              dart analyze --fatal-infos
            else
              echo "No Dart files found, skipping Dart linting."
            fi
          else
            echo "dart SDK not installed, skipping Dart linting."
          fi

      # Apple Ecosystem Linting (Swift / Obj-C)
      - name: Run Swiftformat and Swiftlint
        run: |
          if command -v swiftformat &> /dev/null && command -v swiftlint &> /dev/null; then
            if [ -n "$(find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f -name '*.swift' -print -quit)" ]; then
              swiftformat --lint .
              swiftlint lint --strict
            else
              echo "No Swift files found, skipping Swift linting."
            fi
          else
            echo "swiftformat or swiftlint not installed. Skipping Swift linting."
          fi

      - name: Run clang-format (Obj-C / C++)
        run: |
          if command -v clang-format &> /dev/null; then
            if [ -n "$(find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f \( -name '*.m' -o -name '*.mm' -o -name '*.h' -o -name '*.c' -o -name '*.cpp' \) -print -quit)" ]; then
              find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f \( -name '*.m' -o -name '*.mm' -o -name '*.h' -o -name '*.c' -o -name '*.cpp' \) -exec clang-format --dry-run --Werror {} +
            else
              echo "No Obj-C/C++ files found, skipping clang-format."
            fi
          else
            echo "clang-format not installed. Skipping C-family linting."
          fi

      # Cloud Native & Infrastructure as Code (IaC)
      - name: Run Kube-Linter and TFLint
        run: |
          if ! command -v kube-linter &> /dev/null; then
            echo "kube-linter not installed. Attempting to install via brew..."
            brew install kube-linter || echo "Failed to install kube-linter."
          fi
          if command -v kube-linter &> /dev/null; then
            # Assuming k8s yaml files might be in specific directories (e.g. k8s, manifests), running broadly but ignoring dotfiles ideally.
            (find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f \( -name '*.yaml' -o -name '*.yml' \) -print0 | xargs -0 kube-linter lint) || echo "kube-linter found issues. Please review them."
          fi

          if ! command -v tflint &> /dev/null; then
            echo "tflint not installed. Attempting to install via brew..."
            brew install tflint || echo "Failed to install tflint."
          fi
          if command -v tflint &> /dev/null; then
            if [ -n "$(find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f -name '*.tf' -print -quit)" ]; then
              tflint --init
              tflint
            else
              echo "No Terraform (.tf) files found, skipping tflint."
            fi
          fi

      # Android Ecosystem Linting (Kotlin / Java)
      - name: Run ktlint and google-java-format
        run: |
          if command -v ktlint &> /dev/null; then
            if [ -n "$(find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f -name '*.kt' -print -quit)" ]; then
              ktlint
            else
              echo "No Kotlin files found, skipping ktlint."
            fi
          else
            echo "ktlint not installed. Skipping Kotlin linting."
          fi

          if command -v google-java-format &> /dev/null; then
            if [ -n "$(find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f -name '*.java' -print -quit)" ]; then
              find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f -name '*.java' -exec google-java-format --set-exit-if-changed --dry-run {} +
            else
              echo "No Java files found, skipping google-java-format."
            fi
          else
            echo "google-java-format not installed. Skipping Java linting."
          fi

      # API Contracts Linting (Spectral)
      - name: Run Spectral (OpenAPI / AsyncAPI)
        run: |
          if [ -n "$(find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f \( -iname '*openapi*.yaml' -o -iname '*openapi*.yml' -o -iname '*openapi*.json' -o -iname '*swagger*.yaml' -o -iname '*swagger*.yml' -o -iname '*swagger*.json' -o -iname '*asyncapi*.yaml' -o -iname '*asyncapi*.yml' -o -iname '*asyncapi*.json' \) -print -quit)" ]; then
            find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f \( -iname '*openapi*.yaml' -o -iname '*openapi*.yml' -o -iname '*openapi*.json' -o -iname '*swagger*.yaml' -o -iname '*swagger*.yml' -o -iname '*swagger*.json' -o -iname '*asyncapi*.yaml' -o -iname '*asyncapi*.yml' -o -iname '*asyncapi*.json' \) -exec npx @stoplight/spectral-cli lint {} +
          else
            echo "No OpenAPI/Swagger/AsyncAPI files found, skipping Spectral."
          fi

      # Shell Scripts linting (excluding dependencies, running native binary)
      - name: Run ShellCheck
        run: |
          find . -type f -name "*.sh" -not -path "*/\.venv/*" -not -path "*/node_modules/*" -not -path "*/venv/*" -not -path "*/env/*" -not -path "*/dist/*" -not -path "*/build/*" -not -path "*/\.git/*" -not -path "*/\.specify/scripts/*" -exec bash -c 'shellcheck "$@"' _ {} +

      # Shell Scripts formatting (shfmt)
      - name: Run shfmt
        run: |
          sudo apt-get update && sudo apt-get install -y shfmt
          find . -type f -name "*.sh" -not -path "*/\.venv/*" -not -path "*/node_modules/*" -not -path "*/venv/*" -not -path "*/env/*" -not -path "*/dist/*" -not -path "*/build/*" -not -path "*/\.git/*" -not -path "*/\.specify/scripts/*" -exec shfmt -d {} +

      # PowerShell Scripts linting (using ubuntu runner's pre-installed pwsh)
      - name: Run PSScriptAnalyzer
        shell: pwsh
        run: |
          Set-PSRepository PSGallery -InstallationPolicy Trusted
          Install-Module -Name PSScriptAnalyzer -Force -ErrorAction Stop
          $scripts = Get-ChildItem -Path . -Recurse -Filter "*.ps1" | Where-Object { $_.FullName -notmatch '[/\\](\\.venv|node_modules|venv|env|dist|build|\\.git|\\.specify[/\\]scripts)[/\\]' }
          if ($null -eq $scripts -or @($scripts).Count -eq 0) {
            Write-Host "No PowerShell scripts found to analyze."
          } else {
            $hasError = $false
            foreach ($script in $scripts) {
              $results = Invoke-ScriptAnalyzer -Path $script.FullName
              if ($results) {
                $results | Format-Table -AutoSize
                $hasError = $true
              }
            }
            if ($hasError) {
              exit 1
            }
          }

      # GitHub Actions Workflows linting
      - name: Run actionlint
        env:
          GITHUB_PROXY: ${{ secrets.GITHUB_PROXY || vars.GH_PROXY || 'https://gh-proxy.sn0wdr1am.com/' }}
        run: |
          bash <(curl -s "${GITHUB_PROXY}https://raw.githubusercontent.com/rhysd/actionlint/main/scripts/download-actionlint.bash")
          ./actionlint

      # Semgrep Light SAST (Security Scanning)
      - name: Run Semgrep
        run: |
          source .venv/bin/activate
          if command -v semgrep &> /dev/null; then
            semgrep scan --config=auto --error
          else
            echo "Semgrep not installed. Skipping SAST."
          fi

      # Trivy SCA / Container Security Scanning
      - name: Run Trivy Vulnerability Scanner
        uses: aquasecurity/trivy-action@0.34.1
        continue-on-error: true
        with:
          scan-type: "fs"
          ignore-unfixed: true
          format: "table"
          severity: "CRITICAL,HIGH"
          db-repository: "public.ecr.aws/aquasecurity/trivy-db"

      # Dockerfile linting
      - name: Run hadolint
        run: |
          find . -type f -name "*Dockerfile*" -not -path "*/\.venv/*" -not -path "*/node_modules/*" -not -path "*/venv/*" -not -path "*/env/*" -not -path "*/dist/*" -not -path "*/build/*" -not -path "*/\.git/*" -not -path "*/\.specify/scripts/*" -print0 | while IFS= read -r -d '' file; do
            echo "Linting $file"
            docker run --rm -i hadolint/hadolint hadolint - < "$file"
          done

      # Makefile linting
      - name: Run checkmake
        env:
          GITHUB_PROXY: ${{ secrets.GITHUB_PROXY || vars.GH_PROXY || 'https://gh-proxy.sn0wdr1am.com/' }}
        run: |
          CHECKMAKE_VER="v0.3.2"
          OS=$(uname -s | tr '[:upper:]' '[:lower:]')
          ARCH=$(uname -m)
          if [ "$ARCH" = "x86_64" ]; then CA="amd64"; elif [ "$ARCH" = "aarch64" ] || [ "$ARCH" = "arm64" ]; then CA="arm64"; else CA=$ARCH; fi
          curl -fL --retry 3 "${GITHUB_PROXY}https://github.com/checkmake/checkmake/releases/download/${CHECKMAKE_VER}/checkmake-${CHECKMAKE_VER}.${OS}.${CA}" -o checkmake
          chmod +x checkmake
          if [ -n "$(find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f -name 'Makefile' -print -quit)" ]; then
            find . -type d \( -name .git -o -name node_modules -o -name .venv -o -name venv -o -name env -o -name vendor -o -name dist -o -name build -o -name out -o -name target -o -name .next -o -name .nuxt -o -name .output -o -name __pycache__ -o -name .specify \) -prune -o -type f -name 'Makefile' -exec ./checkmake {} +
          else
            echo "No Makefile found, skipping checkmake."
          fi
