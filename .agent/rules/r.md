# R Development Guidelines

> Objective: Define standards for reproducible, clean, and collaborative R code (data science and statistics).

## 1. Project Structure & Reproducibility

- Use the **`{renv}`** package for dependency management. Create `renv.lock` and commit it to version control for fully reproducible environments across machines and CI.
- Use the **`{targets}`** pipeline framework for complex, multi-step data analyses. It caches intermediate results and automatically re-runs only what changed — essential for long-running computations.
- Organize projects with a clear directory structure:

  ```text
  R/                   # Functions and scripts (sourced by analysis scripts)
  data/raw/            # Original, immutable raw data (never modified)
  data/processed/      # Transformed data (generated by scripts)
  output/              # Figures, tables, reports (generated output)
  reports/             # R Markdown / Quarto documents
  tests/testthat/      # Unit tests
  ```

- Never modify raw data files directly. All transformations must be scripted and reproducible from source.

## 2. Code Style

- Follow the **tidyverse style guide**. Use `snake_case` for all variable and function names. Use `PascalCase` for R6 class names.
- Use the native **pipe operator** (`|>`, R ≥ 4.1) for readable data transformation chains. Use `%>%` (magrittr) only in pre-4.1 projects or when you need a placeholder (`.`).
- Limit line length to **80 characters**. Split long function calls onto multiple lines. Use `styler::style_file()` to auto-format.
- Lint with **`{lintr}`** in CI: `lintr::lint_dir("R/")`. Commit `.lintr` config to enforce project-specific rules.
- Prefer explicit function calls with namespaces when there is potential ambiguity: `dplyr::filter()` instead of `filter()`.

## 3. Functions & Validation

- Write small, single-purpose functions. Functions longer than ~30 lines are candidates for decomposition.
- Document all exported functions in packages with **`{roxygen2}`** (`#'` comments) including `@param`, `@return`, `@examples`, and `@export`.
- Use `stopifnot()` or **`{checkmate}`** for input validation at the start of functions. Fail fast with informative error messages.
- **Avoid `<<-`** (global assignment from within a function). It creates hidden state and makes code difficult to reason about and test. Use return values or R6 class fields instead.
- Use functional programming patterns with **`{purrr}`** (`map()`, `walk()`, `reduce()`) rather than `for` loops for operations on lists or data frames.

## 4. Reproducibility & Reporting

- Set a random seed (`set.seed(42)`) at the start of any script or function involving randomness. Document the seed choice in comments.
- Use **R Markdown** or **Quarto** for all reports combining code, output, and narrative. Render reports in CI to verify they execute cleanly end-to-end.
- Use **`{here}`** package (`here::here("data", "raw", "file.csv")`) for all file paths — never hardcode absolute paths or use `setwd()`.
- Version control both code and rendered outputs (HTML/PDF) when reports are the primary deliverable, so stakeholders can view changes without re-running.

## 5. Data Handling & Testing

- Use **`{dplyr}`**, **`{tidyr}`**, and **`{purrr}`** for data manipulation and functional programming. Prefer tidy, rectangular data over nested lists for analysis.
- Prefer `readr::read_csv()` over base R `read.csv()` for consistent column type inference, faster parsing, and explicit encoding handling. Use `readr::problems()` to inspect parse errors.
- Write unit tests for functions with **`{testthat}`**. Test edge cases: empty data frames, `NA` values, single-row inputs, unexpected column types.
- Use **`{vdiffr}`** for snapshot testing of ggplot2 plots and **`{mockery}`** or `testthat::local_mocked_bindings()` for mocking in tests.
- Use **`{bench}`** for performance benchmarking. Track benchmark results in CI to catch performance regressions.
