# C Language Development Guidelines

> Objective: Define standards for safe, portable, and maintainable C code.

## 1. C Standard & Compiler Warnings

- Target **C11** (`-std=c11`) for new projects. Use **C99** as the minimum for maximum portability to embedded and legacy platforms.
- Use `<stdint.h>` for **fixed-width integer types** (`uint8_t`, `int32_t`, `uint64_t`). Never rely on `int` or `long` having a specific size — it varies by platform and compiler.
- Enable all warnings and treat them as errors in CI: `gcc -Wall -Wextra -Wpedantic -Werror -Wformat=2 -Wshadow -Wconversion -Wundef -Wstrict-prototypes`.
- Use `_Static_assert(condition, "message")` for compile-time invariant checks (C11).
- Compile with multiple compilers in CI (GCC and Clang) to catch compiler-specific bugs and maximize portability.

## 2. Memory Safety

- Every `malloc()` / `calloc()` call **MUST check for a `NULL` return** before using the pointer. OOM conditions are real, especially on embedded systems:

  ```c
  int *buf = malloc(n * sizeof(int));
  if (!buf) { perror("malloc"); return -1; }
  ```

- Every allocated resource **MUST have a corresponding `free()`**. Use structured ownership: document in comments which function owns each allocation and is responsible for freeing it.
- Set pointers to `NULL` after `free()` to prevent use-after-free and double-free bugs: `free(p); p = NULL;`.
- Use **AddressSanitizer** (`-fsanitize=address,leak`) and **Undefined Behavior Sanitizer** (`-fsanitize=undefined`) in CI builds. Use **Valgrind** for detailed memory analysis on Linux.
- Prefer stack allocation for small, fixed-size objects. Heap-allocate only when the object lifetime must outlive its lexical scope or when size is dynamic.

## 3. Pointers & Strings

- Prefer `const T *` for pointer parameters that must not modify the pointed-to data. Apply `const` correctness throughout — it is a form of documentation and enables compiler optimizations.
- **Never use `gets()`** (removed in C11). Always use `fgets(buf, sizeof(buf), stdin)` with an explicit buffer size.
- Use `snprintf()` over `sprintf()` for all formatted string output. Always pass `sizeof(buf)` as the size argument.
- Use `strncat()` / `strncpy()` over `strcat()` / `strcpy()`. Prefer `strlcat` / `strlcpy` (BSD/macOS) where available, or implement a safe equivalent for Linux.
- Avoid pointer arithmetic beyond the bounds of an array. Use `ptrdiff_t` for differences between pointers.

## 4. Macros & Preprocessor

- Use `enum` or `static const T` instead of `#define` for typed constants — they participate in type checking and are visible to debuggers.
- Always wrap multi-statement macros in `do { ... } while(0)` to make them behave correctly in `if`/`else` contexts.
- Protect all header files with include guards. Prefer `#pragma once` for modern compilers, or the traditional `#ifndef` guard:

  ```c
  #pragma once
  /* OR */
  #ifndef MY_HEADER_H
  #define MY_HEADER_H
  /* ... */
  #endif /* MY_HEADER_H */
  ```

- Minimize macro usage. Prefer `inline` functions for type safety. Use macros only for functionality that cannot be expressed as a function (e.g., stringification, token pasting).

## 5. Build & Tooling

- Use **CMake** (3.20+) as the primary build system for cross-platform projects. Structure with `src/`, `include/`, `tests/` directories. Use `target_compile_features` and `target_compile_options` for per-target settings.
- Format with **clang-format** (commit `.clang-format` to the repository). Lint with **clang-tidy** and **cppcheck**. Enforce both in CI.
- Use **Unity** or **cmocka** for unit testing. Aim for coverage of all public API functions. Run tests with sanitizers enabled in CI.
- For security-critical code parsing untrusted input (file formats, network protocols), add **fuzzing** with **AFL++** or **libFuzzer**.
- Use **`compilation_commands.json`** (generated by CMake with `-DCMAKE_EXPORT_COMPILE_COMMANDS=ON`) to enable accurate IDE analysis and clang-tidy integration.
