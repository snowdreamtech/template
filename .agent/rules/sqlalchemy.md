# SQLAlchemy Development Guidelines

> Objective: Define standards for using SQLAlchemy 2.x safely and efficiently in Python applications.

## 1. Engine & Session Setup

- Create a **single `Engine` instance** per application and reuse it. Configure the connection pool explicitly:
  ```python
  engine = create_async_engine(
      DATABASE_URL,
      pool_size=10,
      max_overflow=20,
      pool_pre_ping=True,
      echo=False,  # Set True only in development to log SQL
  )
  ```
- Use `pool_pre_ping=True` to automatically handle stale/dead connections.
- Use **`async_sessionmaker`** (SQLAlchemy 2.x) to create an `AsyncSession` factory. Manage session lifecycle via a context manager or dependency injection (FastAPI `Depends`).
- **Never share sessions across requests, threads, or across async boundaries.** Each request must get its own session.

## 2. ORM Models (Declarative 2.x Style)

- Define all models using the **`DeclarativeBase`** class (SQLAlchemy 2.0+).
- Use **typed annotations** (`Mapped[int]`, `Mapped[str]`, `mapped_column()`) for full type safety and IDE support:
  ```python
  class User(Base):
      __tablename__ = "users"
      id: Mapped[int] = mapped_column(primary_key=True)
      email: Mapped[str] = mapped_column(String(255), unique=True, nullable=False)
      created_at: Mapped[datetime] = mapped_column(server_default=func.now())
  ```
- Always define `__tablename__` explicitly. Use `snake_case` for table and column names.

## 3. Querying (SQLAlchemy 2.x Style)

- Use the **2.x `select()` style** exclusively: `session.execute(select(User).where(User.id == uid))`. **Avoid the legacy `session.query()` API** — it is slated for eventual deprecation.
- Use `scalars()` to retrieve ORM objects: `(await session.scalars(select(User))).all()`.
- Use **`selectinload()`** (preferred for async) or **`joinedload()`** for eager loading relationships. **Never use lazy loading** (`lazy="dynamic"`) in async code — it raises errors with `AsyncSession`.
- Never interpolate user input into SQL strings. Use bound parameters with `text()`: `text("WHERE name = :name").bindparams(name=user_input)`.

## 4. Transactions

- Sessions operate in a transaction by default. Use `await session.commit()` to persist and `await session.rollback()` to revert.
- Use `async with session.begin():` as a context manager for explicit, exception-safe transaction boundaries.
- Never call `commit()` inside a loop — batch writes and commit once at the end.
- Use **savepoints** (`session.begin_nested()`) for nested transactions when you need partial rollback capability.

## 5. Migrations

- Use **Alembic** for all schema migrations. Generate migration scripts with `alembic revision --autogenerate -m "add_users_table"`.
- **Review autogenerated migrations carefully** before applying — autogenerate does not detect all changes (e.g., check constraints, column type changes).
- Run `alembic upgrade head` in CI/CD pipelines **before** starting the application.
- Commit all migration files in `alembic/versions/` to version control. Never edit applied migrations.
