# SQLAlchemy Development Guidelines

> Objective: Define standards for using SQLAlchemy 2.x safely and efficiently in Python applications.

## 1. Engine & Session Setup

- Create a **single `Engine` instance** per application and reuse it. Configure the connection pool explicitly:

  ```python
  engine = create_async_engine(
      DATABASE_URL,
      pool_size=10,
      max_overflow=20,
      pool_pre_ping=True,   # Recycles stale/dead connections automatically
      echo=False,           # Set True only in development to log SQL
  )
  ```

- Use **`async_sessionmaker`** (SQLAlchemy 2.x) to create an `AsyncSession` factory. Manage session lifecycle via a context manager or dependency injection (FastAPI `Depends`).
- **Never share sessions across requests, threads, or async boundaries.** Each request must get its own session from the factory.
- Use `expire_on_commit=False` on the session maker when returning model objects from endpoints, to prevent expired attribute access errors after commit.

## 2. ORM Models (Declarative 2.x Style)

- Define all models using the **`DeclarativeBase`** class (SQLAlchemy 2.0+).
- Use **typed annotations** (`Mapped[int]`, `Mapped[str]`, `mapped_column()`) for full type safety and IDE support:

  ```python
  class User(Base):
      __tablename__ = "users"
      id: Mapped[int] = mapped_column(primary_key=True)
      email: Mapped[str] = mapped_column(String(255), unique=True, nullable=False)
      created_at: Mapped[datetime] = mapped_column(server_default=func.now())
  ```

- Always define `__tablename__` explicitly. Use `snake_case` for table and column names.
- Use `Index("ix_users_email", "email")` or `__table_args__` for composite indexes not expressible via column options.

## 3. Querying (SQLAlchemy 2.x Style)

- Use the **2.x `select()` style** exclusively: `session.execute(select(User).where(User.id == uid))`. **Avoid the legacy `session.query()` API** — it is deprecated in 2.x.
- Use `scalars()` to retrieve ORM objects: `(await session.scalars(select(User))).all()`.
- Use **`selectinload()`** (preferred for async) or **`joinedload()`** for eager loading relationships. **Never use lazy loading** in async code — it raises `MissingGreenlet` errors with `AsyncSession`.
- Never interpolate user input into SQL strings. Use bound parameters with `text()`: `text("WHERE name = :name").bindparams(name=user_input)`.
- Use `with_only_columns()` or `select(User.id, User.name)` to select specific columns and avoid over-fetching.

## 4. Transactions

- Sessions operate in a transaction by default. Use `await session.commit()` to persist and `await session.rollback()` to revert.
- Use `async with session.begin():` as a context manager for explicit, exception-safe transaction boundaries that auto-commit on success and auto-rollback on exception.
- Never call `commit()` inside a loop — batch writes and commit once at the end for performance.
- Use **savepoints** (`session.begin_nested()`) for nested transactions when you need partial rollback capability within a larger transaction.

## 5. Migrations

- Use **Alembic** for all schema migrations. Generate migration scripts with `alembic revision --autogenerate -m "add_users_table"`.
- **Review autogenerated migrations carefully** before applying — autogenerate does not detect all changes (check constraints, column server defaults, column type changes on some backends).
- Run `alembic upgrade head` in CI/CD pipelines **before** starting the application. Use `alembic check` to verify no pending migrations exist.
- Commit all migration files in `alembic/versions/` to version control. Never edit a migration file after it has been applied to any environment.
- Use **`alembic downgrade`** scripts to define safe rollbacks. Test that downgrade scripts work before deploying to production.
